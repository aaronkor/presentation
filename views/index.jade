DOCTYPE

html
  head
    meta(charset='utf-8')
    title Introduction to Node.js | Aaron Kor

    //stylesheets
    link(rel='stylesheet', href='media/css/font.css')
    link(rel='stylesheet', href='media/css/default.css')
    link(rel='stylesheet', href='media/highlight/styles/sunburst.css')

  body
    //impress
    #impress.impress-not-supported
      #fm1.fallback-message.hidden
        p Your browser does not support the features required by impress.js
      
      #fm1.fallback-message
        p Your browser does not support the features required by impress.js

      #introduction.step
        h2 Introduction to
        img(id='nodejsLogo', class='centered', src='media/img/nodelogo.png', alt='Node.JS')
        p.footer Aaron Kor &nbsp&nbsp| &nbsp&nbsp Apr 2015

      #nodejs-is.step
        h2 node.js is
        ul
          li Server-side JavaScript
          li Built on top of Google V8 engine
          li CommonJS support
          li Very Scalable
          li
            strong Event-driven, non blocking I/O

      #io-expensive.step
        h2 The I/O is expensive
        img(id='io', class='centered', src='media/img/io-cost.png', alt='The cost of I/O')

      #deal.step
        center
          h3 How to deal with it?
        ol.center
          li Synchronous
          li Process forking
          li Multi-threaded
      
      #graphs.step
        center
          h3 
            strong A Tale Of Two Web Servers
          img(class="graph", src="media/img/nginx-apache-reqs-sec.png", alt="Apache vs Nginx - Requests per second")
          br
          br
          img(class="graph", src="media/img/nginx-apache-memory.png", alt="Apache vs Nginx - Memory")
          br

      #difference.step
        h2 The difference?
        center
          p
            b Apache 
            | (classic server) - uses thread per connection
          p
            b Nginx 
            | (node.js equivalent) - uses event loop

      #threads-wrong.step
        center
          h3 So, what's wrong with threads?
          p Context switching is not free
          p Execution stacks take up memory

      #in-node.step
        h2 In node.js
        center
          h3 everything runs in parallel
          h3#except
            | EXCEPT YOUR CODE

      #king.step
        center
          h2 Your Code
          img(src='media/img/king.png', alt='king image')

      #event-loop.step
        center
          h2 Event Loop
          img.event-loop(src='media/img/event-loop.jpg', alt='event loop diagram')

      #node-query.step
        p A conventional code
        pre
          code
            | var result = db.query("select ...");
            | // use result

        p will be written in node as
        pre
          code
            | db.query("select ...", function (result) {
            |   // use result
            | });

      #timeout-example.step
        p For example
        pre
          code
            | setTimeout( function () {
            |   console.log("DARY!");
            | }, 5000);
            | console.log("LEGEN...");
          a(class='runButton', href='#', onClick='invokeTimeoutExample()') Run!
        p will yield
        pre
          code#timeoutOutput &nbsp

      #write-code.step
        h1 Show me some real code !!!11
      
      #npm.step
        center
          h3 The 
            b NPM 
            i (node package manager)
          center
            p 
              i Uses 
                b package.json 
        pre
          code
            | {
            |   "name" : "node-presentation",
            |   "version" : "0.2.1",
            |   "author" : "Aaron Kor",
            |   "description" : "A node.js presentation",
            |   "dependencies": {
            |     "express" : "4.12.*",
            |     "jade" : "1.*",
            |     "socket.io" : "*"
            |   },
            |   "devDependencies": { 
            |     "nodeunit" : "*"
            |   },
            |   "engine" : {
            |     "node" : ">=0.12"
            |   }
            | }
           
      #packages.step
        center
          h2 Enterprise level packages
          h3 Frontend / Middleware
          ul.horizontal
            li Express
            li Tower
            li Geddy
          br
          h3 Data Store Native Drivers
          ul.horizontal
            li Oracle
            li SQL Server
            li MongoDB

      #usecases.step
        h2 Use Cases
        ul
          li PayPal - 2x increase in productivity
          ul
            li Reusing NPM modules
            li Using same language on the entire stack
          li WalMart - released <b>on Black Friday!</b>
          ul
            li $1.5bn spent by customers
            li Serving over 500 million page views

      #more.step
        center
          h2 Many More...
          ul.horizontal.logos
            li
              img(src='media/img/microsoft.jpg', alt='microsoft')
            li
              img(src='media/img/google.png', alt='google')
            li
              img(src='media/img/uber.png', alt='uber')
            li
              img(src='media/img/linkedin.png', alt='linkedin')
            li
              img(src='media/img/ebay.png', alt='ebay')
            li
              img(src='media/img/yahoo.jpg', alt='yahoo')

      #advantages.step
        h2 Advantages
        ul
          li performance & scalability
          li maintainability
          li client / server sharing assets
          li productivity
          li vibrant dev community
          li trendy!
          li ... no more "hung threads" messages

      #disadvantages.step
        h2 Disadvantages
        ul
          li need to avoid CPU heavy implementations
          li "Callback Hell"
        center
          h3 &#x21D3;
          h3 Better JavaScript knowledge needed

      #blocks.step
        center
          h3 Building blocks of digital-enterprise architecture
        ul
          li Two-speed architecture
          li Microservices
          li Zero downtime
          li Realtime data analytics

      #twospeed.step
        h3 
          b Two-speed architecture
        h3 Node.js covers the fast speed part
      
      #microservices.step
        h3 
          b Microservices
        h3 Node.js is modular, cross-platform, easily maintaineable
      
      #zerodowntime.step
        h3 
          b Zero downtime
        h3 Node.js can be deployed with zero downtime
        p forever.js, liveswap.js, process.on('SIGTERM', ...), Cluster, ...

      #realtime.step
        h3 
          b Realtime data analytics
        h3 Node.js was built for realtime streaming
        p e.g socket.io, integration with schema-less data stores

      #further.step
        center
          h2 Further Information
        ul
          li 
            a(target='blank' href='http://nodejs.org') nodejs.org
            | /
            a(target='blank' href='http://npmjs.org') npmjs.com
          li
            a(target='blank' href='http://www.nodebeginner.org') nodebeginner.org
          li 
            a(target='blank' href='http://lmgtfy.com/?q=node.js') just Google "node.js"
          li
            h3 Floor 8, Cube #43

      #thanks.step
        h2 Thanks.
        center
          br
          p fork the presentation from
          a(target='blank' href='http://www.github.com/aaronkor/presentation')
            | http://www.github.com/aaronkor/presentation
          p.footer Aaron Kor

      #overview.step
      //end of all steps

      //javascripts
      script(src='media/highlight/highlight.pack.js')
      script(src='media/js/impress.js')
      script(src='media/js/default.js')
      script(src='socket.io/socket.io.js')
      script(type='text/javascript').
        
        function writeOutput(text) {
          var field = document.getElementById('timeoutOutput').childNodes[0];
          if(field) {
            field.textContent += text;
          }
        }

        var socket = io.connect('http://localhost:3001');
        socket.on('timeout-example-response', function(data) {
          console.log(data);
          writeOutput(data);
        });

        function invokeTimeoutExample () {
          console.log('invokeTimeoutExample');
          socket.emit('timeout-example-request', null);
        }
